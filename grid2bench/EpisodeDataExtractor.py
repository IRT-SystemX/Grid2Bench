# Copyright (C) 2022,
# IRT-SystemX (https://www.irt-systemx.fr), RTE (https://www.rte-france.com)
# See authors in pyporject.toml
# SPDX-License-Identifier: MPL-2.0

""" This module is used to extract only the information we need from
the agent log files generated by the `grid2op package
<https://github.com/rte-france/Grid2Op>`_


Log files are obtained either by evaluating agent performance using the
`L2RPN score <https://grid2op.readthedocs.io/en/latest/utils.html>`_ or
by running the agent using the `Runner class
<https://grid2op.readthedocs.io/en/latest/runner.html>`_ in grid2op.

  Typical usage example of the module:

  .. code-block:: python

    from grid2bench.EpisodeDataExtractor import EpisodeDataExtractor
    from datetime import datetime
    import numpy as np

    # import episode data
    agent_log_path = '../data/input/Expert_Agent'
    episode_name = 'dec16_1'
    episode_data = EpisodeDataExtractor(agent_log_path, episode_name)

    date_time = datetime(year=2012, month=12, day=4, hour=7, minute=5)

    act = episode_data.get_action_by_timestamp(date_time)
    obs = episode_data.get_observation_by_timestamp(date_time)

    line_statuses = obs.line_status
    subs_on_bus_2 = np.repeat(False, obs.n_sub)
    objs_on_bus_2 = {id: [] for id in range(obs.n_sub)}

    distance, _, _, _ = episode_data.get_distance_from_obs(
    act,
    line_statuses,
    subs_on_bus_2,
    objs_on_bus_2,
    obs)

    print('Distance from initial topology of the second action is :', distance)
"""

import os
from datetime import timedelta, datetime
from typing import List

import numpy as np
import pandas as pd
from grid2op.Action import BaseAction
from grid2op.Episode import EpisodeData
from grid2op.Observation import BaseObservation


class EpisodeDataExtractor:
  """This class is used to extract and transform data from agent evaluation
  results log files.

  Extract only the useful information for us from grid2op's
  :class:`EpisodeData` class to reduce memory size, then prepare this data
  to calculate evaluation metrics.

  Attributes:

  - agent_log_path: agent's log file path
  - agent_name: agent's name, as the same name as the agent folder
  - episode_name: episode name as the same name as the episode folder
  - observations: list of observations in the episode
  - actions: list of actions in the episode
  - n_observation: number of observations in the episode
  - n_action: number of actions in the episode, usually n_observation -1
  - timestamps: list of episode timestamps
  - computation_times: list of agent's action execution times
  - cum_reward: cumulative reward of the episode
  - max_timestep: maximum time steps in the episode
  - nb_timestep_played: number of played time steps completed in the episode
    before a game over.

  """

  def __init__(self, agent_log_path: str, episode_name: str):
    """Init and loading data for the class.

    :param agent_log_path: agent log file path
    :type agent_log_path: str
    :param episode_name: episode name as the same name as the episode folder
    :type episode_name: str
    """

    self.agent_log_path: str = os.path.abspath(agent_log_path)
    self.agent_name: str = os.path.basename(agent_log_path)
    self.episode_name: str = episode_name

    try:
      episode_data = EpisodeData.from_disk(agent_path=self.agent_log_path,
                                           name=self.episode_name)

    except (FileNotFoundError, IOError):
      print('Wrong episode name or agent path')

    else:
      self.observations: list[BaseObservation] = episode_data.observations
      self.actions: list[BaseAction] = episode_data.actions

      self.n_observation: int = len(self.observations)
      self.n_action: int = len(self.actions)

      self.timestamps: list[datetime] = [self.observations[i].get_time_stamp()
                                         for i in range(self.n_action)]

      self.computation_times: list[float] = episode_data.times
      self.cum_reward: list[float] = episode_data.meta['cumulative_reward']
      self.nb_timestep_played: list[int] = episode_data.meta[
        'nb_timestep_played']

      self.max_timestep: int = episode_data.meta['chronics_max_timestep']

      # TODO --> i don't think this is the correct way to calculate action id
      # create actions_id
      self.list_actions = []
      for act in self.actions:
        if act and self.get_action_id(act) is None:
          self.list_actions.append(act)

      # clear memory
      del episode_data

  def get_observation_by_timestamp(self,
                                   date_time: datetime) -> BaseObservation:
    """Get the grid2op observation object whose timestamp is date_time.

    :param date_time: the datetime sought
    :type date_time: datetime
    :return: Observation if exists otherwise raise Error
    :rtype: grid2op.BaseObservation object

    Example of usage:

    .. code-block:: python

      from grid2bench.EpisodeDataExtractor import EpisodeDataExtractor
      from datetime import datetime

      # import episode data
      agent_log_path = '../data/input/Expert_Agent'
      episode_name = 'dec16_1'
      episode_data = EpisodeDataExtractor(agent_log_path, episode_name)

      date_time = datetime(year=2012, month=12, day=4, hour=7, minute=0)
      obs = episode_data.get_observation_by_timestamp(date_time)
      print(obs.to_vect())

    """
    return self.observations[self.timestamps.index(date_time)]

  def get_action_by_timestamp(self, date_time: datetime) -> BaseAction:
    """Get the grid2op action object whose timestamp is date_time.

    :param date_time: the datetime sought
    :type date_time: datetime
    :return: Action if exists otherwise raise Error
    :rtype: grid2op.BaseAction object

    Example of usage:

    .. code-block:: python

      from grid2bench.EpisodeDataExtractor import EpisodeDataExtractor
      from datetime import datetime

      # import episode data
      agent_log_path = '../data/input/Expert_Agent'
      episode_name = 'dec16_1'
      episode_data = EpisodeDataExtractor(agent_log_path, episode_name)

      date_time = datetime(year=2012, month=12, day=4, hour=7, minute=0)
      act = episode_data.get_observation_by_timestamp(date_time)
      print(act)

    """
    return self.actions[self.timestamps.index(date_time)]

  def get_computation_time_by_timestamp(self, date_time: datetime) -> float:
    """Get agent action execution time at timestamp date_time.

    :param date_time: the datetime sought
    :type date_time: datetime
    :return: action execution time in seconds if found, raise an error otherwise
    :rtype: float

    Example of usage:

    .. code-block:: python

      from grid2bench.EpisodeDataExtractor import EpisodeDataExtractor
      from datetime import datetime

      # import episode data
      agent_log_path = '../data/input/Expert_Agent'
      episode_name = 'dec16_1'
      episode_data = EpisodeDataExtractor(agent_log_path, episode_name)

      date_time = datetime(year=2012, month=12, day=4, hour=7, minute=0)
      execution_time = episode_data.get_computation_time_by_timestamp(
      date_time)
      print(execution_time, 's')


    """
    return self.computation_times[self.timestamps.index(date_time)]

  def get_timestep_by_datetime(self, date_time: datetime) -> int:
    """Get the order of a given timestamp in the episode.

    :param date_time: datetime sought
    :type date_time: datetime
    :return: order of the date_time, raise an error otherwise
    :rtype: int

    Example of usage:

    .. code-block:: python

      from grid2bench.EpisodeDataExtractor import EpisodeDataExtractor
      from datetime import datetime

      # import episode data
      agent_log_path = '../data/input/Expert_Agent'
      episode_name = 'dec16_1'
      episode_data = EpisodeDataExtractor(agent_log_path, episode_name)

      date_time = datetime(year=2012, month=12, day=4, hour=7, minute=10)
      timestep = episode_data.get_timestep_by_datetime(date_time)
      print('The timestep of {} is {}'.format(date_time, timestep))

    """
    return self.timestamps.index(date_time)

  def actions_freq_by_timestamp(self) -> pd.DataFrame:
    """Calculate the number of unit actions in the episode.

    Unit actions including switched lines, topological impacts, redispatching,
    storage and curtailment.

    :return: a DataFrame time series with columns: Timestamp, nb of unit
      actions, impacted substations and impacted lines.
    :rtype: DataFrame

    Example of usage:

    .. code-block:: python

      from grid2bench.EpisodeDataExtractor import EpisodeDataExtractor

      # import episode data
      agent_log_path = '../data/input/Expert_Agent'
      episode_name = 'dec16_1'
      episode_data = EpisodeDataExtractor(agent_log_path, episode_name)

      df = episode_data.actions_freq_by_timestamp()
      print(df)

    """
    action_freq = []

    for i in range(self.n_action - 1):
      action_impact = self.actions[i].impact_on_objects()

      if action_impact['has_impact']:
        nb_actions = (  # number of lines switched
            action_impact['switch_line'][
              'count'] +  # number of topological changes
            len(action_impact['topology']['bus_switch']) + len(
          action_impact['topology']['assigned_bus']) + len(
          action_impact['topology'][
            'disconnect_bus']) +  # number of redispatch changes
            len(action_impact['redispatch'][
                  'generators']) +  # number of storage changes
            len(action_impact['storage'][
                  'capacities']) +  # number of curtailment changes
            len(action_impact['curtailment']['limit']))

        if nb_actions != 0:
          action_freq.append(
            {'Timestamp': self.timestamps[i], 'NB action': nb_actions,
             'Impacted subs': self.impacted_subs(i),
             'Impacted lines': self.impacted_lines(i)})

    return pd.DataFrame(action_freq,
                        columns=['Timestamp', 'NB action', 'Impacted subs',
                                 'Impacted lines'])

  def impacted_lines(self, timestep: int) -> List[str]:
    """Returns the lines impacted by an action with a given time step.

    :param timestep: the time step in the episode
    :type timestep: int
    :return: list of impacted line names
    :rtype: list of strings

    Example of usage :

    .. code-block:: python

      from grid2bench.EpisodeDataExtractor import EpisodeDataExtractor

      # import episode data
      agent_log_path = '../data/input/Expert_Agent'
      episode_name = 'dec16_1'
      episode_data = EpisodeDataExtractor(agent_log_path, episode_name)

      impacted_lines = episode_data.impacted_lines(timestep=0)
      print(impacted_lines)
    """

    lines_impacted = self.actions[timestep].get_topological_impact()[0]
    return self.actions[timestep].name_line[np.where(lines_impacted)].tolist()

  def impacted_subs(self, timestep: int) -> List[str]:
    """Returns the substations impacted by an action with a given time step.

    :param timestep: the time step in the episode
    :type timestep: int
    :return: list of impacted substation names
    :rtype: list of strings

    Example of usage :

    .. code-block:: python

      from grid2bench.EpisodeDataExtractor import EpisodeDataExtractor

      # import episode data
      agent_log_path = '../data/input/Expert_Agent'
      episode_name = 'dec16_1'
      episode_data = EpisodeDataExtractor(agent_log_path, episode_name)

      impacted_subs = episode_data.impacted_subs(timestep=0)
      print(impacted_subs)

    """

    subs_impacted = self.actions[timestep].get_topological_impact()[1]
    return self.actions[timestep].name_sub[np.where(subs_impacted)].tolist()

  def actions_freq_by_type(self) -> pd.DataFrame:
    """Returns the number of unit actions by type and at each timestamp in
    the episode.

    Unit actions including switched lines, topological impacts, redispatching,
    storage and curtailment.

    :return: a DataFrame time series with columns: Timestamp, NB line switched,
      NB topological change, NB redispatching, NB storage changes, NB curtailment
    :rtype: DataFrame

    Example of usage :

    .. code-block:: python

      from grid2bench.EpisodeDataExtractor import EpisodeDataExtractor

      # import episode data
      agent_log_path = '../data/input/Expert_Agent'
      episode_name = 'dec16_1'
      episode_data = EpisodeDataExtractor(agent_log_path, episode_name)

      df = episode_data.actions_freq_by_type()
      print(df)

    """
    timestamps = []
    nb_switch_line = []
    nb_topological_changes = []
    nb_redispatch_changes = []
    nb_storage_changes = []
    nb_curtailment_changes = []

    for i in range(self.n_action - 1):
      action_impact = self.actions[i].impact_on_objects()

      if action_impact['has_impact']:
        # timestamp
        timestamps.append(self.timestamps[i])
        # number of switched lines
        nb_switch_line.append(action_impact['switch_line']['count'])
        # number of topological changes
        nb_topological_changes.append(
          len(action_impact['topology']['bus_switch']) + len(
            action_impact['topology']['assigned_bus']) + len(
            action_impact['topology']['disconnect_bus']))
        # number of redispatching
        nb_redispatch_changes.append(
          len(action_impact['redispatch']['generators']))
        # number of storage changes
        nb_storage_changes.append(len(action_impact['storage']['capacities']))
        # number of curtailment
        nb_curtailment_changes.append(
          len(action_impact['curtailment']['limit']))

    dict_actions_freq = {'Timestamp': timestamps,
                         'NB line switched': nb_switch_line,
                         'NB topological change': nb_topological_changes,
                         'NB redispatching': nb_redispatch_changes,
                         'NB storage changes': nb_storage_changes,
                         'NB curtailment': nb_curtailment_changes}

    return pd.DataFrame(dict_actions_freq)

  def impacted_subs_by_timestamp(self) -> list[dict[str, datetime, set]]:
    """Returns the impacted substations at each timestamp within the episode.

    :return: substation impacted by agent actions
    :rtype: a list of dictionaries {Timestamp, Sub impacted}

    Example of usage :

    .. code-block:: python

      from grid2bench.EpisodeDataExtractor import EpisodeDataExtractor

      # import episode data
      agent_log_path = '../data/input/Expert_Agent'
      episode_name = 'dec16_1'
      episode_data = EpisodeDataExtractor(agent_log_path, episode_name)

      dict_list = episode_data.impacted_subs_by_timestamp()
      print(dict_list)
    """
    subs_impacted_by_timestamp = []

    for action, i in zip(self.actions, range(self.n_action - 1)):

      subs_impacted = action.get_topological_impact()[1]
      list_subs_impacted = action.name_sub[np.where(subs_impacted)]

      if len(list_subs_impacted) != 0:
        subs_impacted_by_timestamp.append({'Timestamp': self.timestamps[i],
                                           'subs_impacted': set(
                                             list_subs_impacted)})

    return subs_impacted_by_timestamp

  def overloaded_lines_by_timestamp(self) -> list[dict[str, datetime, set]]:
    """Returns overloaded lines at each episode timestamp

    :return: overloaded lines impacted by agent actions
    :rtype: a list of dictionaries {Timestamp, Overloaded lines}

    Example of usage :

    .. code-block:: python

      from grid2bench.EpisodeDataExtractor import EpisodeDataExtractor

      # import episode data
      agent_log_path = '../data/input/Expert_Agent'
      episode_name = 'dec16_1'
      episode_data = EpisodeDataExtractor(agent_log_path, episode_name)

      dict_list = episode_data.overloaded_lines_by_timestamp()
      print(dict_list)

    """

    overloaded_lines = []

    for observation, i in zip(self.observations, range(self.n_action)):

      lines_id = np.where(observation.timestep_overflow != 0)[0]

      if len(lines_id) != 0:
        overloaded_lines.append(
          {'Timestamp': self.timestamps[i], 'Overloaded lines': set(lines_id)})

    return overloaded_lines

  def disconnected_lines_by_timestamp(self) -> list[dict[str, datetime, set]]:
    """Returns disconnected lines at each episode timestamp

    :return: disconnected lines impacted by agent actions
    :rtype: a list of dictionaries {Timestamp, Disconnected lines}

    Example of usage :

    .. code-block:: python

      from grid2bench.EpisodeDataExtractor import EpisodeDataExtractor

      # import episode data
      agent_log_path = '../data/input/Expert_Agent'
      episode_name = 'dec16_1'
      episode_data = EpisodeDataExtractor(agent_log_path, episode_name)

      dict_list = episode_data.disconnected_lines_by_timestamp()
      print(dict_list)
    """

    disconnected_lines = []

    for observation, i in zip(self.observations, range(self.n_action)):

      lines_id = np.where(observation.line_status != True)[0]

      if len(lines_id) != 0:
        disconnected_lines.append({'Timestamp': self.timestamps[i],
                                   'Disconnected lines': set(lines_id)})

    return disconnected_lines

  def compute_action_sequences_length(self) -> pd.DataFrame:
    """Calculate the length of action sequence in an episode.

    A sequence of actions is defined by taking several actions in a
    non-disconnected sequence of time steps. A non-disconnected sequence means
    that there is no "do nothing" in the sequence.

    Examples:

    - Sequence 1 : Switch bus action, Topological changes, Do nothing
      --> Sequence of length 2
    - Sequence 2 : Switch bus action, Do nothing, Topological changes
      --> not a sequence
    - Sequence 3 : Switch bus action, Topological changes, Do nothing, Switch
      bus action, Topological changes, Topological changes, Do nothing -->
      two sequences, the first of length 2 and the second of length 3

    :return: a DataFrame time series with columns: Timestamp, Sequence
      length, NB line switched, NB topological change, NB redispatching,
      NB storage changes, NB curtailment
    :rtype: DataFrame

    Example of usage :

    .. code-block:: python

      from grid2bench.EpisodeDataExtractor import EpisodeDataExtractor

      # import episode data
      agent_log_path = '../data/input/Expert_Agent'
      episode_name = 'dec16_1'
      episode_data = EpisodeDataExtractor(agent_log_path, episode_name)

      df_actions_sequence = episode_data.compute_action_sequences_length()
      print(df_actions_sequence)
    """

    # action sequence length
    action_sequences_length = self.actions_freq_by_timestamp().copy()

    columns = ['Sequence length']
    action_sequences_length.insert(1, 'Sequence length',
                                   action_sequences_length['NB action'])
    df = action_sequences_length[columns]
    df[df > 0] = 1
    action_sequences_length.loc[:, columns] = df

    for column in columns:
      for i in range(1, len(action_sequences_length)):
        if action_sequences_length.loc[i, column] != 0:
          previous_timestamp = action_sequences_length.loc[
                                 i, 'Timestamp'] - timedelta(minutes=5)
          if previous_timestamp in list(action_sequences_length['Timestamp']):
            if action_sequences_length.loc[i - 1, column] != 0:
              action_sequences_length.loc[i, column] = \
                action_sequences_length.loc[i - 1, column] + 1

    return action_sequences_length

  def _n_lines(self) -> int:
    """Returns the number of lines in the power grid.

    :return: the line id if exists, raise an error otherwise
    :rtype: int
    """
    return self.observations[0].n_line

  def _name_of_lines(self, lines_id: int) -> str:
    """Returns the name of lines in the power grid.

    :return: the line's name if exists, raise an error otherwise
    :rtype: str
    """
    return self.actions[0].name_line[lines_id]

  # function reused from grid2vis, see https://github.com/rte-france/grid2viz
  def get_distance_from_obs(self, act, line_statuses, subs_on_bus_2,
                            objs_on_bus_2, obs):
    """Calculate the number of changes compared to the initial topology

    A function reused from grid2vis package (
    https://github.com/rte-france/grid2viz)

    :param act: the agent's action
    :type act: grid2op.BaseAction object
    :param line_statuses: line status (connected/disconnected)
    :type line_statuses: list
    :param subs_on_bus_2: substation connected on buses 2
    :type subs_on_bus_2: list
    :param objs_on_bus_2: objects connected on buses 2
    :type objs_on_bus_2: list
    :param obs: observation
    :type obs: grid2op.BaseObservation
    :return: distance, line_statuses, subs_on_bus_2, objs_on_bus_2
    :rtype: tuple
    """

    impact_on_objs = act.impact_on_objects()

    # lines reconnections/disconnections
    line_statuses[
      impact_on_objs['force_line']['disconnections']['powerlines']] = False
    line_statuses[
      impact_on_objs['force_line']['reconnections']['powerlines']] = True
    line_statuses[impact_on_objs['switch_line']['powerlines']] = np.invert(
      line_statuses[impact_on_objs['switch_line']['powerlines']])

    topo_vect_dict = {'load': obs.load_pos_topo_vect,
                      'generator': obs.gen_pos_topo_vect,
                      'line (extremity)': obs.line_ex_pos_topo_vect,
                      'line (origin)': obs.line_or_pos_topo_vect, }

    # Bus manipulation
    if impact_on_objs['topology']['changed']:
      for modif_type in ['bus_switch', 'assigned_bus']:

        for elem in impact_on_objs['topology'][modif_type]:
          objs_on_bus_2 = self.update_objs_on_bus(objs_on_bus_2, elem,
                                                  topo_vect_dict,
                                                  kind=modif_type)

      for elem in impact_on_objs['topology']['disconnect_bus']:
        # Disconnected bus counts as one for the distance
        subs_on_bus_2[elem['substation']] = True

    subs_on_bus_2 = [True if objs_on_2 else False for _, objs_on_2 in
                     objs_on_bus_2.items()]

    distance = len(line_statuses) - line_statuses.sum() + sum(subs_on_bus_2)
    return distance, line_statuses, subs_on_bus_2, objs_on_bus_2

  # function reused from grid2vis, see https://github.com/rte-france/grid2viz
  def update_objs_on_bus(self, objs_on_bus_2, elem, topo_vect_dict, kind):
    for object_type, pos_topo_vect in topo_vect_dict.items():
      if elem['object_type'] == object_type and elem['bus']:
        if kind == 'bus_switch':
          objs_on_bus_2 = self.update_objs_on_bus_switch(objs_on_bus_2, elem,
                                                         pos_topo_vect)
        else:
          objs_on_bus_2 = self.update_objs_on_bus_assign(objs_on_bus_2, elem,
                                                         pos_topo_vect)
        break
    return objs_on_bus_2

  # function reused from grid2vis, see https://github.com/rte-france/grid2viz
  @staticmethod
  def update_objs_on_bus_switch(objs_on_bus_2, elem, pos_topo_vect):
    if pos_topo_vect[elem['object_id']] in objs_on_bus_2[elem['substation']]:
      # elem was on bus 2, remove it from objs_on_bus_2
      objs_on_bus_2[elem['substation']] = [x for x in
                                           objs_on_bus_2[elem['substation']] if
                                           x != pos_topo_vect[
                                             elem['object_id']]]
    else:
      objs_on_bus_2[elem['substation']].append(pos_topo_vect[elem['object_id']])
    return objs_on_bus_2

  # function reused from grid2vis, see https://github.com/rte-france/grid2viz
  @staticmethod
  def update_objs_on_bus_assign(objs_on_bus_2, elem, pos_topo_vect):
    if (pos_topo_vect[elem['object_id']] in objs_on_bus_2[
      elem['substation']] and elem['bus'] == 1):
      # elem was on bus 2, remove it from objs_on_bus_2
      objs_on_bus_2[elem['substation']] = [x for x in
                                           objs_on_bus_2[elem['substation']] if
                                           x != pos_topo_vect[
                                             elem['object_id']]]
    elif (pos_topo_vect[elem['object_id']] not in objs_on_bus_2[
      elem['substation']] and elem['bus'] == 2):
      objs_on_bus_2[elem['substation']].append(pos_topo_vect[elem['object_id']])
    return objs_on_bus_2

  # TODO optimize --> Fereshteh

  def create_topology_df(self):
    c1 = 0
    c2 = 0
    c3 = 0

    topo_df = pd.DataFrame(
      columns=['t_step', 'time_stamp', 'action_id', 'type', 'object_type',
               'object_id', 'susbtation'])
    for i in range(0, len(self.actions)):

      t = self.timestamps[i]
      a_id = self.get_action_id(self.actions[i])
      d = self.actions[i].impact_on_objects()
      if d['has_impact']:
        c1 += len(d['topology']['disconnect_bus'])
        c2 += len(d['topology']['bus_switch'])
        c3 += len(d['topology']['assigned_bus'])
        for j in d:
          if (type(d[j]) is dict) and (d[j]['changed']):
            if j == 'topology':
              if d['topology']['bus_switch']:
                for n in range(0, len(d['topology']['bus_switch'])):
                  o_type = d['topology']['bus_switch'][n]['object_type']
                  o_id = d['topology']['bus_switch'][n]['object_id']
                  subs = d['topology']['bus_switch'][n]['substation']
                  topo_df.loc[len(topo_df)] = [i, t, a_id, 'swithc_bus', o_type,
                                               o_id, subs]

              if d['topology']['assigned_bus']:
                for n in range(0, len(d['topology']['assigned_bus'])):
                  # print(d['topology']['assigned_bus'][n])
                  print('assigned_bus')
                  o_type = d['topology']['assigned_bus'][n]['object_type']
                  o_id = d['topology']['assigned_bus'][n]['object_id']
                  subs = d['topology']['assigned_bus'][n]['substation']
                  topo_df.loc[len(topo_df)] = [i, t, a_id, 'assigned_bus',
                                               o_type, o_id, subs]

              if d['topology']['disconnect_bus']:
                for n in range(0, len(d['topology']['disconnect_bus'])):
                  o_type = d['topology']['disconnect_bus'][n]['object_type']
                  o_id = d['topology']['disconnect_bus'][n]['object_id']
                  subs = d['topology']['disconnect_bus'][n]['substation']
                  topo_df.loc[len(topo_df)] = [i, t, a_id, 'disconnect_bus',
                                               o_type, o_id, subs]

    return [c1 + c2 + c3, topo_df]

  def create_injection_df(self):
    c = 0
    inj_df = pd.DataFrame(
      columns=['t_step', 'time_stamp', 'action_id', 'count', 'impacted'])
    for i in range(0, len(self.actions)):
      t = self.timestamps[i]
      a_id = self.get_action_id(self.actions[i])
      d = self.actions[i].impact_on_objects()
      if d['has_impact']:
        for j in d:
          if (type(d[j]) is dict) and (d[j]['changed']):
            if j == 'injection':
              c += d['injection']['count']
              co = d['injection']['count']
              impacted = d['injection']['impacted']
              inj_df.loc[len(inj_df)] = [i, t, a_id, co, impacted]
    return (c, inj_df)

  def create_dispatch_df(self):
    c = 0
    dispatch_df = pd.DataFrame(
      columns=['t_step', 'time_stamp', 'action_id', 'generator_id',
               'generator_name', 'amount'])

    for i in range(0, len(self.actions)):
      t = self.timestamps[i]
      a_id = self.get_action_id(self.actions[i])
      d = self.actions[i].impact_on_objects()
      if d['has_impact']:
        for j in d:
          if (type(d[j]) is dict) and (d[j]['changed']):
            if j == 'redispatch':
              c += 1
              gen = (d[j]['generators'][0])
              gen_id = gen['gen_id']
              gen_name = gen['gen_name']
              amount = gen['amount']
              # print([i, gen_id, gen_name, amount ])
              dispatch_df.loc[len(dispatch_df)] = [i, t, a_id, gen_id, gen_name,
                                                   amount]

    return (c, dispatch_df)

  def create_force_line_df(self):
    c1 = 0
    c2 = 0
    line_df = pd.DataFrame(
      columns=['t_step', 'time_stamp', 'action_id', 'type', 'powerline'])
    for i in range(0, len(self.actions)):
      t = self.timestamps[i]
      a_id = self.get_action_id(self.actions[i])
      d = self.actions[i].impact_on_objects()
      if d['has_impact']:
        for j in d:
          if (type(d[j]) is dict) and (d[j]['changed']):
            if j == 'force_line':
              c1 += d[j]['reconnections']['count']
              c2 += d[j]['disconnections']['count']
              if d[j]['reconnections']['count'] > 0:
                line_df.loc[len(line_df)] = [i, t, a_id, 'reconnection',
                                             d[j]['reconnections'][
                                               'powerlines']]
              if d[j]['disconnections']['count'] > 0:
                line_df.loc[len(line_df)] = [i, t, a_id, 'disconnection',
                                             d[j]['reconnections'][
                                               'powerlines']]
    return (c1 + c2, line_df)

  def create_curtailment_df(self):
    c = 0
    curtailment_df = pd.DataFrame(
      columns=['t_step', 'time_stamp', 'action_id', 'limit'])
    for i in range(0, len(self.actions)):
      t = self.timestamps[i]
      a_id = self.get_action_id(self.actions[i])
      d = self.actions[i].impact_on_objects()
      if d['has_impact']:
        for j in d:
          if (type(d[j]) is dict) and (d[j]['changed']):
            if j == 'curtailment':
              c += len(d[j]['limit'])
              if len(d[j]['limit']) > 0:
                curtailment_df.loc[len(curtailment_df)] = [i, t, a_id,
                                                           d[j]['limit']]
    return (c, curtailment_df)

  def create_storage_df(self):
    c = 0
    storage_df = pd.DataFrame(
      columns=['t_step', 'time_stamp', 'action_id', 'capacities'])
    for i in range(0, len(self.actions)):
      t = self.timestamps[i]
      a_id = self.get_action_id(self.actions[i])
      d = self.actions[i].impact_on_objects()
      if d['has_impact']:
        for j in d:
          if (type(d[j]) is dict) and (d[j]['changed']):
            if j == 'storage':
              c += len(d[j]['capacities'])
              if len(d[j]['capacities']) > 0:
                storage_df.loc[len(storage_df)] = [i, t, a_id,
                                                   d[j]['capacities']]
    return (c, storage_df)

  def get_action_id(self, action):
    for idx, act_dict in enumerate(self.list_actions):
      if action == act_dict:
        return idx
    return None
